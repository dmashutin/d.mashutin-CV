


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xml:lang="" lang="" version="-//W3C//DTD XHTML 1.1//EN" xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

  
  <title>Взаимодействие с функциями Windows API в PowerShell &mdash; CV and Samples  documentation</title>
  

  

  

    <link href='https://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'/>
    <link rel="stylesheet" href="_static/css/pdj.css" type="text/css" />

  

  

  
        <link rel="index" title="Index"
              href="genindex.html"/>
        <link rel="search" title="Search" href="search.html"/>
    <link rel="top" title="CV and Samples  documentation" href="index.html"/>
        <link rel="next" title="How to Interact with Windows API Functions in PowerShell" href="winapi_en.html"/>
        <link rel="prev" title="Encoding Unicode: UTF-8 vs. UTF-16" href="Encoding.html"/>

    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta http-equiv="cache-control" content="public" />
    <meta name="robots" content="follow, all" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- Add jQuery library -->
    <script type="text/javascript" src="http://code.jquery.com/jquery-latest.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

  </head>

  <body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        <a href="index.html" class="fa fa-home"> CV and Samples </a>
        <div role="search">
	  <form id ="rtd-search-form" class="wy-form"
		action="search.html" method="get">
	    <input type="text" name="q" placeholder="Search docs" />
	    <input type="hidden" name="check_keywords" value="yes" />
	    <input type="hidden" name="area" value="default" />
	  </form>
	</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
	
          
          
              <ul>
<li class="toctree-l1"><a class="reference internal" href="CV.html">CV in Russian</a><ul>
<li class="toctree-l2"><a class="reference internal" href="CV.html#id2">Навыки и качества</a></li>
<li class="toctree-l2"><a class="reference internal" href="CV.html#id3">Места работы и обязанности</a></li>
<li class="toctree-l2"><a class="reference internal" href="CV.html#id4">Образование</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="CV_en.html">CV in English</a><ul>
<li class="toctree-l2"><a class="reference internal" href="CV_en.html#skills-and-attributes">Skills and Attributes</a></li>
<li class="toctree-l2"><a class="reference internal" href="CV_en.html#previous-positions-and-tasks">Previous Positions and Tasks</a></li>
<li class="toctree-l2"><a class="reference internal" href="CV_en.html#education">Education</a></li>
</ul>
</li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Encoding.html">Encoding Unicode: UTF-8 vs. UTF-16</a><ul>
<li class="toctree-l2"><a class="reference internal" href="Encoding.html#before-unicode">Before Unicode</a></li>
<li class="toctree-l2"><a class="reference internal" href="Encoding.html#the-unicode-standard">The Unicode Standard</a></li>
<li class="toctree-l2"><a class="reference internal" href="Encoding.html#utf-8-vs-utf-16-in-software-development">UTF-8 vs. UTF-16 in Software Development</a></li>
<li class="toctree-l2"><a class="reference internal" href="Encoding.html#conclusion">Conclusion</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Взаимодействие с функциями Windows API в PowerShell</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#add-type">Использование командлета Add-Type</a></li>
<li class="toctree-l2"><a class="reference internal" href="#net">Извлечение приватных методов .NET</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id4">Рефлексия</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id6">Выбор способа</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="winapi_en.html">How to Interact with Windows API Functions in PowerShell</a><ul>
<li class="toctree-l2"><a class="reference internal" href="winapi_en.html#add-type-cmdlet">Add-Type cmdlet</a></li>
<li class="toctree-l2"><a class="reference internal" href="winapi_en.html#extraction-of-private-net-methods">Extraction of private .NET methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="winapi_en.html#reflection">Reflection</a></li>
<li class="toctree-l2"><a class="reference internal" href="winapi_en.html#how-to-choose">How to choose</a></li>
</ul>
</li>
</ul>

          
        

      </div>
      &nbsp;
    </nav>
    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      <nav class="wy-nav-top" id="barra-mobile" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="#">Porão do Juca</a>
      </nav>

      <div class="wy-nav-content">
	<div class="fundo-claro">
	</div>
	<div class="fundo-escuro">
	</div>

        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
	    
	    <!-- <ul class="wy-breadcrumbs"> -->
	    <!--   <li><a href="#">Docs</a> &raquo;</li> -->

	    <!--   <li>Features</li> -->
	    <!--   <li class="wy-breadcrumbs-aside"> -->

	    <!-- 	<a href="_sources/index.txt" rel="nofollow"> View page source</a> -->

	    <!--   </li> -->
	    <!-- </ul> -->
	    <!-- <hr/> -->
	  </div>

          <div role="main" class="">

	    <div id="content" class="hfeed entry-container hentry">
  <div class="section" id="windows-api-powershell">
<h1>Взаимодействие с функциями Windows API в PowerShell<a class="headerlink" href="#windows-api-powershell" title="Permalink to this headline">¶</a></h1>
<p>Windows PowerShell это объектно-ориентированная командная оболочка с поддержкой сценариев. Она функционирует на основе платформы .NET Framework. В работе PowerShell используются классы .NET, которые содержат свойства и методы. Эта командная оболочка позволяет эффективно выполнять задачи, связанные с обслуживанием операционной системы, настройкой серверов, установкой программного обеспечения и автоматизированным администрированием сетей.</p>
<p>Однако существуют отдельные низкоуровневые задачи, для которых недостаточно стандартной функциональности Windows PowerShell. Для их выполнения необходимо обращение к функциям Windows API, которые содержатся в системных динамических библиотеках (DLL). Непосредственный вызов функций WinAPI не поддерживается, однако существуют способы получить доступ к методам таких функций в текущем сеансе PowerShell:</p>
<ol class="arabic simple">
<li><p>Использование командлета Add-Type</p></li>
<li><p>Извлечение приватных методов .NET</p></li>
<li><p>Рефлексия</p></li>
</ol>
<div class="section" id="add-type">
<h2>Использование командлета Add-Type<a class="headerlink" href="#add-type" title="Permalink to this headline">¶</a></h2>
<p>Командлет <strong>Add-Type</strong> позволяет скомпилировать код требуемой функции Windows API на языке C# и использовать статический метод .NET в текущем сеансе PowerShell.</p>
<p>Для того чтобы применить командлет <strong>Add-Type</strong>, необходимы сведения о типах данных и параметрах нужной функции Windows API. Эти данные доступны в документации Microsoft. Например, для функции <a class="reference external" href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-showwindowasync">ShowWindowAsync</a> приводится следующий синтаксис:</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="n">BOOL</span> <span class="nf">ShowWindowAsync</span><span class="p">(</span>
  <span class="n">HWND</span> <span class="n">hWnd</span><span class="p">,</span>
  <span class="kt">int</span>  <span class="n">nCmdShow</span>
<span class="p">);</span>
</pre></div>
</div>
<p>Данная функция имеет тип возвращаемого значения BOOL и два параметра – дескриптор окна <strong>hWnd</strong> и целочисченный <strong>nCmdShow</strong>.</p>
<p>Для обращения к функции WinAPI в среде PowerShell ее необходимо «обернуть» в код C#. На сайте <a class="reference external" href="http://www.pinvoke.net/">pinvoke.net</a> представлены сигнатуры C# для большинства существующих функций WinAPI. Функции рассортированы в алфавитном порядке и объединены в группы по динамическим библиотекам. Доступен полнотекстовый поиск. Копирование готового кода C# ускоряет и упрощает добавление методов Windows API в сеанс PowerShell. Использование проверенных сигнатур с сайта pinvoke.net уменьшает вероятность ошибок в коде.</p>
<p>В <a class="reference external" href="http://www.pinvoke.net/default.aspx/user32/ShowWindowAsync.html">разделе</a> функции <strong>ShowWindowAsync</strong> на сайте pinvoke.net представлена следующая сигнатура С#:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="na">[DllImport(&quot;user32.dll&quot;)]</span>
<span class="k">static</span> <span class="k">extern</span> <span class="kt">bool</span> <span class="nf">ShowWindowAsync</span><span class="p">(</span><span class="n">IntPtr</span> <span class="n">hWnd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nCmdShow</span><span class="p">);</span>
</pre></div>
</div>
<p>Как видно из приведенного кода, тип данных <strong>BOOL</strong> в C/C++ соответствует <strong>bool</strong> в .NET, дескриптор <strong>HWND</strong> задается как <strong>IntPtr</strong>, а тип <strong>int</strong> конвертируется без изменений.</p>
<p>Необходимо объявить переменную и присвоить ей значение при помощи скопированной сигнатуры C#:</p>
<div class="highlight-PowerShell notranslate"><div class="highlight"><pre><span></span><span class="nv">$Signature</span> <span class="p">=</span> <span class="sh">@&quot;</span>
<span class="sh">[DllImport(&quot;user32.dll&quot;)]</span>
<span class="sh">public static extern bool ShowWindowAsync(IntPtr hWnd, int nCmdShow);</span>
<span class="sh">&quot;@</span>
</pre></div>
</div>
<p>В приведенном примере сигнатура записывается в переменную <strong>$Signature</strong>. При этом в код сигнатуры добавлено ключевое слово <strong>public</strong>. Это нужно для того, чтобы сделать новый метод доступным в текущем сеансе PowerShell.</p>
<p>Далее следует добавить тип при помощи командлета <strong>Add-Type</strong> и записать его в переменную. В командлет в качестве параметров передаются объявленная ранее переменная с сигнатурой C#, наименование типа <strong>name</strong> и пространство имен <strong>namespace</strong>.</p>
<div class="highlight-PowerShell notranslate"><div class="highlight"><pre><span></span><span class="nv">$ShowWindowAsync</span> <span class="p">=</span> <span class="nb">Add-Type</span> <span class="n">-MemberDefinition</span> <span class="nv">$Signature</span> <span class="n">-Name</span> <span class="s2">&quot;Win32ShowWindowAsync&quot;</span> <span class="n">-Namespace</span> <span class="n">Win32Functions</span> <span class="n">-PassThru</span>
</pre></div>
</div>
<p>По умолчанию командлет Add-Type не создает объект для метода в текущем сеансе PowerShell. Для этого нужно дополнительно указать параметр <strong>PassThru</strong>. В дальнейшем для ссылок на класс в текущем сеансе PowerShell можно будет использовать заданные наименование типа и пространство имен следующим образом: “[Win32Functions.Win32ShowWindowAsync]”.</p>
<p>Вот пример обращения к добавленному в сеанс PowerShell статическому методу функции WinAPI:</p>
<div class="highlight-PowerShell notranslate"><div class="highlight"><pre><span></span><span class="nv">$ShowWindowAsync</span><span class="p">::</span><span class="n">ShowWindowAsync</span><span class="p">((</span><span class="nb">Get-Process</span> <span class="n">-Id</span> <span class="nv">$pid</span><span class="p">).</span><span class="n">MainWindowHandle</span><span class="p">,</span> <span class="n">2</span><span class="p">)</span>
</pre></div>
</div>
<p>Для вызова статического метода .NET необходимо поставить два двоеточия между переменной и наименованием метода. В примере выше метод функции <strong>ShowWindowAsync</strong> используется для сворачивания активного окна. Для этого командлет <strong>Get-Process</strong> при помощи переменной <strong>$pid</strong> получает идентификатор процесса, который сопоставлен текущему сеансу PowerShell. Затем метод <strong>ShowWindowAsync</strong> присваивает дескриптору главного окна этого процесса <strong>MainWindowHandle</strong> значение “2”, что соответствует свернутому положению окна.</p>
<p>Аналогичный код можно использовать для создания соответствующей функции в PowerShell. При добавлении скрипта в профиль пользователя метод будет доступен в последующих сеансах.</p>
</div>
<div class="section" id="net">
<h2>Извлечение приватных методов .NET<a class="headerlink" href="#net" title="Permalink to this headline">¶</a></h2>
<p>При работе .NET задействуются функции Windows API. Для вызова функций фреймворк обращается к загруженным динамическим библиотекам при помощи приватных статических методов с атрибутом <strong>DllImport</strong>.</p>
<p>Windows PowerShell позволяет написать скрипт или функцию, которая будет искать ссылку на нужный метод WinAPI по всем загруженным библиотекам. Вот пример такой функции (<a class="reference external" href="https://devblogs.microsoft.com/scripting/use-powershell-to-interact-with-the-windows-api-part-2/">источник</a>):</p>
<div class="highlight-PowerShell notranslate"><div class="highlight"><pre><span></span><span class="k">function</span> <span class="nb">Find-WinAPIFunction</span>
<span class="p">{</span>
     <span class="p">[</span><span class="k">CmdletBinding</span><span class="p">()]</span>
     <span class="p">[</span><span class="n">OutputType</span><span class="p">(</span><span class="no">[System.Reflection.MethodInfo]</span><span class="p">)]</span>
     <span class="k">Param</span>
     <span class="p">(</span>
         <span class="p">[</span><span class="k">Parameter</span><span class="p">(</span><span class="k">Mandatory</span> <span class="p">=</span> <span class="nv">$True</span><span class="p">,</span> <span class="k">Position</span> <span class="p">=</span> <span class="n">0</span><span class="p">)]</span>
         <span class="p">[</span><span class="n">ValidateNotNullOrEmpty</span><span class="p">()]</span>
         <span class="no">[String]</span>
         <span class="nv">$Module</span><span class="p">,</span>
         <span class="p">[</span><span class="k">Parameter</span><span class="p">(</span><span class="k">Mandatory</span> <span class="p">=</span> <span class="nv">$True</span><span class="p">,</span> <span class="k">Position</span> <span class="p">=</span> <span class="n">1</span><span class="p">)]</span>
         <span class="p">[</span><span class="n">ValidateNotNullOrEmpty</span><span class="p">()]</span>
         <span class="no">[String]</span>
         <span class="nv">$FunctionName</span>
     <span class="p">)</span>
     <span class="no">[System.AppDomain]</span><span class="p">::</span><span class="n">CurrentDomain</span><span class="p">.</span><span class="n">GetAssemblies</span><span class="p">()</span> <span class="p">|</span>
        <span class="k">ForEach</span><span class="n">-Object</span> <span class="p">{</span> <span class="nv">$_</span><span class="p">.</span><span class="n">GetTypes</span><span class="p">()</span> <span class="p">}</span> <span class="p">|</span>
            <span class="k">ForEach</span><span class="n">-Object</span> <span class="p">{</span> <span class="nv">$_</span><span class="p">.</span><span class="n">GetMethods</span><span class="p">(</span><span class="s1">&#39;NonPublic, Public, Static&#39;</span><span class="p">)</span> <span class="p">}</span> <span class="p">|</span>
                <span class="k">ForEach</span><span class="n">-Object</span> <span class="p">{</span> <span class="nv">$MethodInfo</span> <span class="p">=</span> <span class="nv">$_</span><span class="p">;</span> <span class="nv">$_</span><span class="p">.</span><span class="n">GetCustomAttributes</span><span class="p">(</span><span class="nv">$false</span><span class="p">)</span> <span class="p">}</span> <span class="p">|</span>
                    <span class="nb">Where-Object</span> <span class="p">{</span>
                        <span class="nv">$MethodInfo</span><span class="p">.</span><span class="n">Name</span><span class="p">.</span><span class="n">ToLower</span><span class="p">()</span> <span class="o">-eq</span> <span class="nv">$FunctionName</span><span class="p">.</span><span class="n">ToLower</span><span class="p">()</span> <span class="o">-and</span>
                        <span class="nv">$_</span><span class="p">.</span><span class="n">Value</span> <span class="o">-eq</span> <span class="nv">$Module</span>
                    <span class="p">}</span> <span class="p">|</span> <span class="k">ForEach</span><span class="n">-Object</span> <span class="p">{</span> <span class="nv">$MethodInfo</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Например, при помощи данной функции можно найти метод <strong>CopyFile</strong> в библиотеке <strong>kernel32.dll</strong> и определить, в каких именно контейнерах он содержится. Для этого необходимо объявить переменную <strong>$CopyFile</strong> и передать в нее результаты поиска «CopyFile» в библиотеке <strong>kernel32.dll</strong> от функции <strong>Find-WinAPIFunction</strong>:</p>
<div class="highlight-PowerShell notranslate"><div class="highlight"><pre><span></span><span class="nv">$CopyFile</span> <span class="p">=</span> <span class="nb">Find-WinAPIFunction</span> <span class="n">kernel32</span><span class="p">.</span><span class="n">dll</span> <span class="n">CopyFile</span>
</pre></div>
</div>
<p>Если «CopyFile» упоминается в загруженных динамических библиотеках несколько раз, функция передаст в переменную массив результатов. Чтобы перезаписать в переменную только первый результат, необходимо выполнить следующее:</p>
<div class="highlight-PowerShell notranslate"><div class="highlight"><pre><span></span><span class="nv">$CopyFile</span> <span class="p">=</span> <span class="nv">$CopyFile</span><span class="p">[</span><span class="n">0</span><span class="p">]</span>
</pre></div>
</div>
<p>Далее следует определить, в каком модуле и типе содержится метод:</p>
<div class="highlight-PowerShell notranslate"><div class="highlight"><pre><span></span><span class="nv">$CopyFile</span><span class="p">.</span><span class="n">Module</span><span class="p">.</span><span class="n">Name</span>
<span class="nv">$CopyFile</span><span class="p">.</span><span class="n">DeclaringType</span><span class="p">.</span><span class="n">FullName</span>
</pre></div>
</div>
<p>При вводе указанных команд в окне консоли PowerShell отобразится следующее:</p>
<img alt="_images/1.png" src="_images/1.png" />
<p>Полученные данные указывают на то, что метод <strong>CopyFile</strong> содержится в библиотеке <strong>mscorlib.dll</strong>, в типе <strong>Microsoft.Win32.Win32Native</strong>.</p>
<p>Зная модуль и тип, в которых содержится метод <strong>CopyFile</strong>, можно добавить в сеанс PowerShell функцию, которая позволит обращаться к данному методу, извлекая его из указанной библиотеки и типа. С примером такой функции можно ознакомиться <a class="reference external" href="https://gallery.technet.microsoft.com/scriptcenter/Copy-RawItem-Private-NET-78917643">здесь</a> .</p>
</div>
<div class="section" id="id4">
<h2>Рефлексия<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h2>
<p>Еще один способ вызова методов функций WinAPI в среде PowerShell – рефлексия. Сначала выполняется интроспекция кода, то есть определение методов и свойств функции. В PowerShell это проще всего реализуется применением командлета <strong>Get-Member</strong>. Затем полученные данные используются для динамической генерации кода.</p>
<p>Для лучшего понимания процесса рефлексии и динамической генерации кода следует представить текущее системное окружение в виде иерархической структуры вложенных контейнеров. Верхний уровень это <strong>AppDomain</strong> текущего сеанса PowerShell. В нем содержится множество сборок. Сборки содержат в себе модули, то есть динамические библиотеки DLL. Модули являются контейнерами типов. Наконец, типы содержат члены, которые и подвергаются рефлексии. Члены типов – это методы, свойства, вложенные типы и события.</p>
<p>Концепция динамической генерации кода предусматривает задание элементов структуры всех уровней вложенности. Сначала задается динамическая сборка в текущем <strong>AppDomain</strong>. Затем последовательно задаются динамический модуль, динамический тип и динамический метод. Динамическому методу присваиваются атрибуты <strong>Public</strong> и <strong>Static</strong>, а также специальный атрибут <strong>DllImport</strong>. В конце применяется метод CreateType, чтобы дать текущему сеансу PowerShell доступ к новому динамическому методу.</p>
<p><a class="reference external" href="https://gallery.technet.microsoft.com/scriptcenter/Copy-RawItem-Reflection-38fae6d4">Здесь</a>  можно ознакомиться с примером функции, в которой применяется описанный выше процесс.</p>
</div>
<div class="section" id="id6">
<h2>Выбор способа<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h2>
<p>Командлет <strong>Add-Type</strong> это наиболее простой способ получить доступ к функциям WinAPI в среде оболочки PowerShell, при этом вероятность появления ошибок в коде небольшая. Данного способа достаточно для доступа к большинству функций их системных динамических библиотек.</p>
<p>Однако при использовании командлета <strong>Add-Type</strong> происходит запись временных файлов на диск и обращение к компилятору языка С# - csc.exe. Это может быть нежелательно тогда, когда требуется минимизировать следы вмешательства. В таких случаях предпочтительнее использовать извлечение приватных методов .NET.</p>
<p>Применение рефлексии оправдано тогда, когда нужной функции WinAPI нет в загруженной части фреймворка .NET, либо она содержится в недоступной из текущего сеанса библиотеке DLL.</p>
</div>
</div>


	    </div>
            <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="winapi_en.html" class="btn btn-neutral float-right" title="How to Interact with Windows API Functions in PowerShell">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="Encoding.html" class="btn btn-neutral" title="Encoding Unicode: UTF-8 vs. UTF-16"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Denis Mashutin.
    </p>
  </div>

  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/jucacrispim/sphinx_pdj_theme">theme</a> provided by <a href="http://poraodojuca.net">Porão do Juca</a>.

</footer>
	</div>
	</div>
	  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
    <script type="text/javascript" src="_static/jquery.js">

    </script>
    <script type="text/javascript" src="_static/underscore.js">

    </script>
    <script type="text/javascript" src="_static/doctools.js">

    </script>
    <script type="text/javascript" src="_static/language_data.js">

    </script>

  

   <script type="text/javascript"
           src="_static/js/theme.js"></script>

   <script type="text/javascript"
           src="_static/js/pdj.js"></script>

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

  </body>
</html>